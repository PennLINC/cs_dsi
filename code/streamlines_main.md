# Main analysis for streamlines:
Documentation for all the analysis steps *after* creating the bundle specific masks in dsi-studio for all cases.

Start with setting up our terminal:
```bash
cd /cbica/projects/csdsi/cleaned_paper_analysis/code
conda activate flywheel
trks=( Arcuate_Fasciculus_L Arcuate_Fasciculus_R Cingulum_Frontal_Parahippocampal_L Cingulum_Frontal_Parahippocampal_R Cingulum_Frontal_Parietal_L Cingulum_Frontal_Parietal_R Cingulum_Parahippocampal_L Cingulum_Parahippocampal_Parietal_L Cingulum_Parahippocampal_Parietal_R Cingulum_Parahippocampal_R Cingulum_Parolfactory_L Cingulum_Parolfactory_R Corpus_Callosum_Body Corpus_Callosum_Forceps_Major Corpus_Callosum_Forceps_Minor Corpus_Callosum_Tapetum Corticospinal_Tract_L Corticospinal_Tract_R Corticostriatal_Tract_Anterior_L Corticostriatal_Tract_Anterior_R Corticostriatal_Tract_Posterior_L Corticostriatal_Tract_Posterior_R Corticostriatal_Tract_Superior_L Corticostriatal_Tract_Superior_R Fornix_L Fornix_R Frontal_Aslant_Tract_L Frontal_Aslant_Tract_R Inferior_Fronto_Occipital_Fasciculus_L Inferior_Fronto_Occipital_Fasciculus_R Inferior_Longitudinal_Fasciculus_L Inferior_Longitudinal_Fasciculus_R Middle_Longitudinal_Fasciculus_L Middle_Longitudinal_Fasciculus_R Optic_Radiation_L Optic_Radiation_R Parietal_Aslant_Tract_L Parietal_Aslant_Tract_R Reticular_Tract_L Reticular_Tract_R Superior_Longitudinal_Fasciculus1_L Superior_Longitudinal_Fasciculus1_R Superior_Longitudinal_Fasciculus2_L Superior_Longitudinal_Fasciculus2_R Superior_Longitudinal_Fasciculus3_L Superior_Longitudinal_Fasciculus3_R Thalamic_Radiation_Anterior_L Thalamic_Radiation_Anterior_R Thalamic_Radiation_Posterior_L Thalamic_Radiation_Posterior_R Thalamic_Radiation_Superior_L Thalamic_Radiation_Superior_R Uncinate_Fasciculus_L Uncinate_Fasciculus_R Vertical_Occipital_Fasciculus_L Vertical_Occipital_Fasciculus_R ) #all tracks
```

Most of the analysis steps here need to be slightly different for each validity metric, so we're usually coding that in an if-case within each python script:
1. Retrospective data (CRASH): same-scan accuracy `retro_wthn_acc`
1. Retrospective data (CRASH): inter-scan accuracy `retro_btwn_acc`
1. Retrospective data (CRASH): inter-scan reliability `retro_btwn_rel`
1. Prospective data (Penn): within-session accuracy. `prosp_wthn_acc`

### 1. Calculate dice scores.
This first step is to just calculate the dice scores for each analysis case and create streamline specific CSVs across all participants. 
We do this in `get_dice_scores.py`
Just for this section, we add another analysis group: `retro_fulldsi_btwn_rel` to get the full DSI pair-wise reliability CSVs. 
1. `retro_fulldsi_btwn_rel`: Pairwise dice scores between sessions of the full DSI. (full DSI inter-scan reliability in paper)
1. `retro_wthn_acc`: Dice score between CS-DSI and full DSI for the **same session** (same-scan accuracy)
1. `retro_btwn_acc`: Dice score between CS-DSI and full DSI for the **pairwise sessions** (inter-scan accuracy)
1. `retro_btwn_rel `: Dice score between bundles generated by a CS-DSI scheme in **pairwise sessions** (inter-scan reliability)
1. `prosp_wthn_acc`: Dice score between CS-DSI and full DSI for the **same session** (for the prospective data)

```bash
#Bootstrap
python get_dice_scores.py $grp $trk #where grp is the analysis group (validation metric) and trk is the desired track.
```

### 2. Concatenate score sheets.
The above step calculated the dice scores for each track, but we want summary figures for all tracks, so we put those CSVs together for ease. We do this in `concatenate_tracks.py`
```bash
python concatenate_tracks.py $grp all_tracks
```

### 3. Make violin plots.
Get violin plots for each track, comparing full DSI reliability with CS-DSI accuracy and reliability. We do this in `make_violins_streamlines.py`

Even though we don't report individual track figures, we still run this script for individual tracks because it also makes violin-friendly CSVs for the next step. The last argument passed determines whether plots are made.
```bash
# for grp in "${grps[@]}"; do   # for each of 4 grps, e.g., `retro_wthn_acc`
# for trk in "${trks[@]} "; do   # for each of all tracks
python make_violins_streamlines.py $grp $trk False
# done; done
```

Get summary violin plot with all tracks. *(for figures 6a, 6c, 7a, 9a)*
```bash
python make_violins_streamlines.py $grp all_tracks True
```

### 4. Permutation Testing:
Permutation testing for each track to get p values. These results are just in the supplementary. The permutations for each case is different enough to warrant a separate script. Note that p values may change as the permutations do. Only performed for the retrospective data.
```bash
for trk in "${trks[@]}"; do
python stats_permute_retro_wthn_acc.py streamlines $trk
python stats_permute_retro_btwn_acc.py streamlines $trk
python stats_permute_retro_btwn_rel.py streamlines $trk
done
```

#### Get summary stats:
```bash
python streamlines_permutation_stats.py $grp 
```

### 5. Get relationships with full DSI reliability
Calculating the collinearity between CS-DSI validity metrics and full DSI reliability *(for figures 6b, 6d, 7b, 9b)*
```bash
python correlate_fullDSI_rel.py $grp
```
